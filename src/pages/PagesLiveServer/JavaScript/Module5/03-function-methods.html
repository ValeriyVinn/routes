<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Методи функцій</title>
    <link rel="stylesheet" href="../css/styles.css" />
  </head>
  <body>
    <a href="../../../../indexLS.html">Home</a>

    <h3>Методи функцій</h3>
    <section class="section">
      <p>
        Трапляються ситуації, коли функцію потрібно викликати в контексті
        об'єкта, при цьому функція не є його методом. Для цього у функцій є
        методи call, apply і bind.
      </p>
      <h4>Метод call()​</h4>
      <pre class="code">
foo.call(obj, arg1, arg2, ...)
</pre
      >
      <p>
        Метод call викличе функцію foo таким чином, що в this буде посилання на
        об'єкт obj, а також передасть аргументи arg1, arg2 тощо.
      </p>
      <pre class="code">
function greetGuest(greeting) {
  console.log(`${greeting}, ${this.username}.`);
}

const mango = {
  username: "Манго",
};
const poly = {
  username: "Полі",
};

greetGuest.call(mango, "Ласкаво просимо"); // Ласкаво просимо, Манго.
greetGuest.call(poly, "З прибуттям"); // З прибуттям, Полі.
</pre
      >
      <h4>Метод apply​</h4>
      <p>
        Метод apply - це аналог методу call за винятком того, що синтаксис
        передачі аргументів вимагає не перерахування, а масив, навіть якщо
        аргумент всього один.
      </p>
      <pre class="code">
foo.call(obj, arg1, arg2, ...)

foo.apply(obj, [arg1, arg2, ...])
  </pre
      >
      <p>
        Метод apply викличе функцію foo таким чином, що в this буде посилання на
        об'єкт obj, а також передасть елементи масиву як окремі аргументи arg1,
        arg2 тощо.
      </p>
      <pre class="code">
function greetGuest(greeting) {
  console.log(`${greeting}, ${this.username}.`);
}

const mango = {
  username: "Манго",
};
const poly = {
  username: "Полі",
};

greetGuest.apply(mango, ["Ласкаво просимо"]); // Ласкаво просимо, Манго.
greetGuest.apply(poly, ["З прибуттям"]); // З прибуттям, Полі.
</pre
      >
      <h4>Метод bind()​</h4>
      <p>
        Методи call і apply викликають функцію «на місці», тобто відразу. Але у
        разі колбек-функцій, коли необхідно не відразу викликати функцію, а
        передати посилання на неї, причому з прив'язаним контекстом,
        використовується метод bind.
      </p>
      <pre class="code">
foo.bind(obj, arg1, arg2, ...)
</pre
      >
      <p>
        Метод bind створює і повертає копію функції foo з прив'язаним контекстом
        obj і аргументами arg1, arg2 тощо. Утворюється копія функції, яку можна
        передати куди завгодно і викликати коли завгодно.
      </p>
      <pre class="code">
function greet(clientName) {
  return `${clientName}, ласкаво просимо в «${this.service}».`;
}

const steam = {
  service: "Steam",
};
const steamGreeter = greet.bind(steam);
steamGreeter("Манго"); // "Манго, ласкаво просимо в «Steam»."

const gmail = {
  service: "Gmail",
};
const gmailGreeter = greet.bind(gmail);
gmailGreeter("Полі"); // "Полі, ласкаво просимо в «Gmail»."
</pre
      >
      <h4>bind() і методи об'єкта​</h4>
      <p>
        У разі передачі методів об'єкта як колбек-функцій, контекст не
        зберігається. Колбек - це посилання на метод, яка присвоюється як
        значення параметра, що викликається без об'єкта.
      </p>
      <pre class="code">
const customer = {
  firstName: "Jacob",
  lastName: "Mercer",
  getFullName() {
    return `${this.firstName} ${this.lastName}`;
  },
};

function makeMessage(callback) {
  // callback() - це виклик методу getFullName без об'єкта
  console.log(`Обробляємо заявку від ${callback()}.`);
}

makeMessage(customer.getFullName); // Виникне помилка на момент виклику функції
</pre
      >
      <p>
        У суворому режимі, значення this в методі getFullName, викликаючи як
        колбек-функції callback(), буде undefined. Звертаючись до властивостей
        firstName і lastName, виникне помилка, оскільки undefined - це не
        об'єкт.
      </p>
      <p>
        Метод bind використовується для прив'язування контексту, передаючи
        методи об'єкта як колбек-функції. Передамо колбеком не оригінальний
        метод getFullName, а його копію з прив'язаним контекстом об'єкту
        customer.
      </p>
      <pre class="code">
// ❌ Було
  makeMessage(customer.getFullName); // Виникне помилка на момент виклику функції
  
// ✅ Стало
  makeMessage(customer.getFullName.bind(customer)); // Обробляємо заявку від Jacob Mercer.
  </pre
      >
    </section>

    <!-- ! -->
    <button class="accordion">Завдання</button>
    <div class="panel">
      <pre><code class="language-js">
Відповідь
</code></pre>
    </div>
    <!-- ! -->
    <button class="accordion">Завдання</button>
    <div class="panel">
      <pre><code class="language-js">
Відповідь
</code></pre>
    </div>
    <!-- ! -->
    <button class="accordion">Завдання</button>
    <div class="panel">
      <pre><code class="language-js">
Відповідь
</code></pre>
    </div>
    <!-- ! -->
    <button class="accordion">Завдання</button>
    <div class="panel">
      <pre><code class="language-js">
Відповідь
</code></pre>
    </div>
    <!-- ! -->
    <button class="accordion">Завдання</button>
    <div class="panel">
      <pre><code class="language-js">
Відповідь
</code></pre>
    </div>

    <!-- ! -->
    <button class="accordion">Завдання</button>
    <div class="panel">
      <pre><code class="language-js">
Відповідь
</code></pre>
    </div>
    <!-- ! -->
    <button class="accordion">Завдання</button>
    <div class="panel">
      <pre><code class="language-js">
Відповідь
</code></pre>
    </div>

    <script src="../js/main.js" type="module"></script>
  </body>
</html>
