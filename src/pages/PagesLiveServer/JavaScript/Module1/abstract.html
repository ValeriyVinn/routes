<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="../css/abstract.css" />
    <title>Module 1 Abstract</title>
  </head>
  <body>
    <a href="../../../../indexLS.html">Home</a>

    <h1>Abstract Модуль 1 - Змінні та типи. Розгалуження. Цикли</h1>
    <h2>JavaScript</h2>
    <section class="section">
      <h3>JavaScript</h3>
      <p>
        <strong>JavaScript</strong> - реалізація специфікації EcmaScript,
        високорівнева мова програмування, яка підтримується усіма сучасними
        веб-браузерами. В першу чергу призначена для взаємодії з елементами
        веб-сторінок і додавання інтерактивності.
      </p>
      <p>
        У Front-end розробці, JavaScript використовується разом із HTML і CSS
        для забезпечення функціональності веб-сторінки, а саме:
      </p>
      <ul class="section-list">
        <li>нескладні обчислення</li>
        <li>перевірка і маніпуляція даними, введеними користувачем</li>
        <li>зберігання інформації в браузері користувача</li>
        <li>динамічна зміна HTML-документа</li>
        <li>реакція на дії користувача</li>
        <li>створення інтерактивних елементів: галерей, графіків і т. п.</li>
        <li>взаємодія з бекендом</li>
      </ul>
      <p>
        <strong
          >На сьогодні, використовуючи JavaScript, можна створювати:</strong
        >
      </p>
      <ul class="section-list">
        <li>
          <strong>веб-застосунки</strong> на фреймворках React, Vue, Angular та
          інших
        </li>
        <li><strong>бекенд-застосунки</strong> на Node.js</li>
        <li><strong>мобільні застосунки</strong> на React Native або Ionic</li>
        <li><strong>десктоп-застосунки</strong> за допомогою Electron</li>
        <li><strong>мікроконтролери</strong> з Johnny-Five і Espruino</li>
      </ul>
    </section>
    <h2>Основи синтаксису</h2>
    <section class="section">
      <h3>Інструкція</h3>
      <p>
        <strong>Інструкція (statement)</strong> - це пов'язаний набір слів і
        символів із синтаксису мови, які об'єднуються з метою вираження однієї
        ідеї, однієї інструкції для машини.
      </p>
      <p>
        Інструкції в JavaScript завершуються крапкою з комою, яку можна
        порівняти із крапкою наприкінці речення вашої рідної мови.
      </p>
      <h3>Вираз</h3>
      <p>
        Інструкції складаються із частин, як і в будь-якій мові речення
        складаються із фраз і ці фрази називаються виразами.
      </p>
      <p>
        Вираз (expression) - посилання на змінну або значення, або на набір
        змінних і значень в поєднанні з операторами.
      </p>
      <i class="italic-strong">
        <strong>
          Інтерфейс - це набір властивостей і методів сутності, доступних для
          використання у вихідному коді.</strong
        ></i
      >
      <h3>Властивість</h3>
      <p>
        Синтаксис звернення до властивості - через крапку: <br />
        сутність.ім`я_властивості
      </p>
      <h3>Метод</h3>
      <p>
        Це виклик дії, якась активна операція. Синтаксис виклику метода дуже
        схожий на звернення до властивості, але в кінці додається пара круглих
        дужок: <br />
        сутність.ім`я_метода()
      </p>
    </section>

    <h2>Змінні і типи</h2>
    <section class="section">
      <h3>Ідентифікатор</h3>
      <p>
        <strong>Ідентифікатор</strong> - це ім'я змінної, функції або класу.
        Складається з одного або декількох символів у наступному форматі.
      </p>
      <ul class="section-list">
        <li>
          Першим символом повинна бути літера a-z або A-Z, символ підкреслення _
          або знак долара $.
        </li>
        <li>
          Інші символи можуть бути літерами a-z, A-Z, цифрами 0-9,
          підкресленнями _ і знаками долара $.
        </li>
        <li>
          Ідентифікатори чуттєві до регістру. Це означає, що змінні user, usEr і
          User - різні.
        </li>
      </ul>
      <p>
        Використання camelCase-нотації для ідентифікаторів - це стандарт. Перше
        слово пишеться малими літерами, а кожне наступне починається з великої.
      </p>
    </section>
    <section class="section">
      <h3>Змінні let i const. Оголошення змінних</h3>
      <p>
        Директива let оголошує змінну з блочною областю видимості з можливістю
        ініціалізувати її значенням.
      </p>
      <p>
        Директива const створює константу (нове іменоване посилання на область
        пам'яті), доступну лише читання. Це не означає, що вказане значення є
        незмінним, але це означає, що ідентифікатор не може бути
        перепризначений. Наприклад, якщо константа вказує на об'єкт, сам об'єкт
        може бути змінений.
      </p>
      <p>
        Єдина відмінність const і let полягає у тому, що const забороняє
        повторно присвоювати змінній будь-яке значення.
      </p>
      <p>Буде розумно використовувати let і const наступним чином:</p>
      <ul class="section-list">
        <li>
          Використовуйте const за замовчуванням, більшість змінних будуть
          оголошені саме таким чином.
        </li>
        <li>
          Використовуйте let, якщо необхідно присвоїти змінній інше значення під
          час виконання скрипту.
        </li>
      </ul>
      <p>
        <strong>Неоголошена (undeclared або not defined) </strong>- це змінна,
        яка не була оголошена в доступній області видимості. Спроба звернутися
        до змінної до її оголошення призведе до помилки.
      </p>
    </section>
    <section class="section">
      <h3>Типи даних</h3>
      <p>
        Існує 8 типів даних. 7 примітивних та 1 складний тип даних. Примітивні
        типи: number, string, boolean, symbol, bigInt, null, undefined. Складний
        тип - object. Він використовується для колекцій даних та для оголошення
        більш складних сутностей. Також він передається за посиланням, а прості
        типи даних за значенням.
      </p>
      <h4>Number</h4>
      <p>
        Значення Number є числами з плаваючою комою, такі як 37 або -9,25.
        Конструктор Number містить константи та методи для роботи з числами.
        Значення інших типів можуть бути перетворені на числа за допомогою
        функції Number(). Найчастіше числа подаються у вигляді прямого запису,
        наприклад 255 або 3.14159.
      </p>
      <h4>String</h4>
      <p>
        Об'єкт String використовується, щоб подати та конструювати послідовність
        символів. Крім регулярних друкованих символів, можна використовувати
        спеціальні символи, які можна закодувати, використовуючи нотацію
        escape-послідовностей
      </p>
      <h4>Boolean</h4>
      <p>
        Об'єкт Boolean представляє значення істинності: true чи false. Значення,
        передане першим параметром, за потреби перетворюється на логічне
        значення. Якщо значення опущено або дорівнює 0, -0, null, false, NaN,
        undefined або порожній рядок (""), об'єкт має початкове значення, що
        дорівнює false. Всі інші значення, включаючи будь-які об'єкти або рядок
        "false", створюють об'єкт з початковим значенням, що дорівнює true.
      </p>
      <h4>Symbol</h4>
      <p>
        Symbol – це вбудований об'єкт, конструктор якого повертає значення
        примітивного типу symbol. Такі значення називають символьними значеннями
        (Symbol value) або просто символами (Symbol), їхня основна особливість у
        тому, що вони гарантують унікальність. Символи часто використовуються як
        унікальні ключі об'єкта. Вони не перетинаються з ключами, які можуть
        бути додані іншим кодом, а також приховані від доступу з іншого коду. Це
        забезпечує можливість слабкої інкапсуляції чи слабку форму приховування
        інформації.
      </p>
      <h4>BigInt</h4>
      <p>
        BigInt це вбудований об'єкт, який надає спосіб репрезентувати цілі числа
        більше 253 - 1, найбільшого числа, яке JavaScript може надійно
        представити з Number примітивом. Це максимальне значення можна отримати,
        звернувшись до Number.MAX_SAFE_INTEGER.
      </p>
      <h4>Null</h4>
      <p>
        Значення null є відсутністю будь-якого об'єктного значення. У
        JavaScript, null є примітивом, і в контексті логічних операцій
        розглядається як хибне (falsy).
      </p>
      <h4>Undefined</h4>
      <p>
        Undefined є властивістю глобального об'єкта, тобто це змінна в
        глобальній області видимості. Початковим значенням undefined є
        примітивне undefined значення. Змінна, не має присвоєного значення, має
        тип undefined. Також undefined повертають метод або інструкція, якщо
        змінна, що бере участь у обчисленнях, не має значення. Функція повертає
        undefined, якщо вона не повертає будь-якого значення.
      </p>
      <h4>Object</h4>
      <p>
        Тип Object є одним з типів даних JavaScript. Він використовується для
        зберігання різних колекцій з ключами та більш складних сутностей.
        Об'єкти можуть бути створені за допомогою конструктора Object() або
        синтаксису ініціалізатора/літералу об'єкта. Майже всі об'єкти JavaScript
        є екземплярами Object; Типовий об'єкт успадковує властивості (включаючи
        методи) від Object.prototype, хоча ці властивості можуть бути затінені
        (тобто перевизначені). Єдині об'єкти, які не успадковують від
        Object.prototype, - це ті, які мають прототип null, або які походять від
        інших об'єктів з прототипом null.
      </p>
      <h4>Оператор typeof</h4>
      <p>
        Використовується для отримання типу значення змінної. Повертає на місце
        свого виклику тип значення змінної, вказаного після нього - рядок, в
        якому вказано тип.
      </p>
    </section>
    <section class="section">
      <h3>Взаємодія з користувачем</h3>
      <h4>Виведення даних</h4>
      <p>
        Для виведення даних існує два методи: console.log() і alert() . В
        круглих дужках зазначаємо ім'я змінної, значення якої необхідно вивести.
        <br />
        <strong>Метод console.log():</strong>
      </p>
      <p class="code">
        const message = "JavaScript is awesome!"; <br />
        console.log(message); // JavaScript is awesome!
      </p>
      <p>
        <strong>Метод alert()</strong> виводить модальне вікно, текст якого
        відповідає значенню змінної (або літерала), яку передаємо в дужках.
      </p>
      <p class="code">
        const message = "JavaScript is awesome!"; <br />
        alert(message);
      </p>
      <h4>Отримання даних</h4>
      <p>
        Це також методи з інтерфейсу window. Результатом свого виконання вони
        повертають те, що було введено користувачем, тому результат їх роботи
        можна записати у змінну для подальшого використання.
      </p>
      <p>
        <strong>confirm()</strong> - виводить модальне вікно з повідомленням, і
        дві кнопки, Ok і Cancel. Натискаючи на Ok, результатом будет true,
        натискаючи на Cancel - повертається false.
      </p>
      <p>
        <strong>prompt()</strong> - виводить модальне вікно з полем введення і
        кнопками Ok і Cancel. Натискаючи на Ok, результатом буде те, що ввів
        користувач, у випадку Cancel - повертається null. Важлива особливість
        prompt полягає в тому, що незалежно від того, що ввів користувач, завжди
        повернеться рядок.
      </p>
    </section>
    <section class="section">
      <h3>Основні оператори</h3>
      <h4>Математичні оператори</h4>
      <p>
        Призначення, функціонал і пріоритет (порядок) операцій нічим не
        відрізняються від шкільного курсу алгебри. Оператори повертають значення
        у вигляді результату виразу.
      </p>
      <h4>Оператори порівняння</h4>
      <p>
        Використовуються для порівняння двох значень. Результатом свого
        виконання повертають буль - true або false, тобто «так» або «ні».
      </p>

      <ul class="section-list">
        <li>a > b і a < b - більше/менше</li>
        <li>a >= b і a <= b - більше/менше або дорівнює</li>
        <li>a == b - рівність</li>
        <li>a != b - нерівність</li>
        <li>a === b - строга рівність</li>
        <li>a !== b - строга нерівність</li>
      </ul>
      <h4>Оператори рівності</h4>
      <p>
        «Нестрогі» оператори рівності == і != виконують перетворення типів
        порівнюваних значень у число, що може призвести до помилок, особливо у
        початківців.
      </p>
      <p>
        Тому для перевірки рівності або нерівності двох значень,
        використовуються тільки оператори === (строга рівність) і !== (строга
        нерівність), які не виконують приведення типів операндів. У такому
        випадку, все дорівнює собі. Перед оцінкою нічого не перетворюється.
      </p>
    </section>
    <section class="section">
      <h3>Числа</h3>
      <p>
        Усі числа в JavaScript, як цілі, так і дробові, мають тип Number і їх
        можна записувати не тільки в десятковій системі числення.
      </p>
      <h4>Приведення до числа</h4>
      <p>
        Більшість арифметичних операцій і математичних функцій перетворюють
        значення у число автоматично. Для того, щоб зробити це явно,
        використовуйте функцію Number(val), передаючи їй у val те, що потрібно
        привести до числа. Якщо значення привести до числа неможливо,
        результатом буде спеціальне числове значення NaN (Not a Number).
        Аналогічним чином відбувається перетворення і в інших математичних
        операторах і функціях. <br />
      </p>
      <p class="code">
        const valueA = "5";<br />
        console.log(Number(valueA)); // 5 <br />
        console.log(typeof Number(valueA)); // "number" <br />
        const valueB = "random string"; <br />
        console.log(Number(valueB)); // NaN <br />
        console.log(typeof Number(valueB)); // "number"
      </p>
      <p>
        Методи Number.parseInt() і Number.parseFloat()​ Перетворюють рядок
        символ за символом, доки це можливо. У разі виникнення помилки
        повертається підсумкове число. Метод Number.parseInt() парсить з рядка
        ціле число.
      </p>
      <p class="code">
        console.log(Number.parseInt("5px")); // 5 <br />
        console.log(Number.parseInt("12qwe74")); // 12<br />
        console.log(Number.parseInt("12.46qwe79")); // 12<br />
        console.log(Number.parseInt("qweqwe")); // NaN
      </p>
      <p>Метод Number.parseFloat() парсить з рядка дробове число.</p>
      <p class="code">
        console.log(Number.parseFloat("5px")); // 5<br />
        console.log(Number.parseFloat("12qwe74")); // 12<br />
        console.log(Number.parseFloat("12.46qwe79")); // 12.46<br />
        console.log(Number.parseFloat("qweqwe")); // NaN
      </p>
      <h4>Перевірка на число</h4>
      <p>
        Для перевірки на число можна використовувати метод Number.isNaN(val).
        Він перевіряє, чи вказане значення є NaN. Метод відповідає на запитання
        "Це Not A Number?" і повертає:
      </p>
      <ul class="section-list">
        <li>true - якщо значення val - NaN</li>
        <li>false - якщо значення val - не NaN</li>
      </ul>
      <p>
        Для всіх значень val, крім NaN, при передачі в Number.isNaN(val) поверне
        false. Цей метод не намагається перетворити val в число, а просто
        виконує перевірку на NaN.
      </p>
      <p class="code">
        const validNumber = Number("51"); // 51<br />
        console.log(Number.isNaN(validNumber)); // false<br />
        const invalidNumber = Number("qweqwe"); // NaN<br />
        console.log(Number.isNaN(invalidNumber)); // true<br />
      </p>
      <h4>Клас Math​</h4>
      <p>
        Один із вбудованих класів, який надає набір методів для роботи з
        числами. Знання всіх методів напам'ять не вимагається, тільки деяких,
        найбільш корисних.
      </p>
      <p class="code">
        // Math.floor(num) - повертає найменше ціле число, // менше, або яке
        дорівнює зазначеному числу<br />
        console.log(Math.floor(1.7)); // 1<br />

        // Math.ceil(num) - повертає найбільше ціле число, більше, або яке
        дорівнює зазначеному числу.<br />
        console.log(Math.ceil(1.2)); // 2<br />

        // Math.round(num) - повертає значення числа, округленого до найближчого
        цілого<br />
        console.log(Math.round(1.2)); // 1<br />
        console.log(Math.round(1.5)); // 2<br />

        // Math.max(num1, num2, ...) - повертає найбільше ціле число з набору<br />
        console.log(Math.max(20, 10, 50, 40)); // 50<br />

        // Math.min(num1, num2, ...) - повертає найменше ціле число з набору<br />
        console.log(Math.min(20, 10, 50, 40)); // 10<br />

        // Math.pow(base, exponent) - піднесення до степеня<br />
        console.log(Math.pow(2, 4)); // 16<br />

        // Math.random() - повертає псевдовипадкове число в діапазоні (0, 1)<br />
        console.log(Math.random()); // випадкове число між 0 і 1<br />
        console.log(Math.random() * (10 - 1) + 1); // псевдовипадкове число від
        1 до 10<br />
      </p>
    </section>
    <section class="section">
      <h3>Рядки</h3>
      <p>
        <strong>Рядок</strong> - це індексований набір з нуля або більше
        символів, взятих в одинарні або подвійні лапки. Вміст рядка не можна
        змінити, лише прочитати. Тобто, не можна взяти будь-який символ і
        замінити його, як тільки рядок створений - він такий назавжди. Можна
        лише створити повністю новий рядок і присвоїти у змінну замість старого.
      </p>
      <h4>Конкатенація рядків</h4>
      <p>
        Якщо застосувати оператор + до рядка і будь-якого іншого типу даних,
        результатом операції «додавання» буде рядок. Ця операція називається
        конкатенація, або додавання рядків. Під час конкатенації, будь-який тип
        даних приводиться до рядка і зшивається з рядком.
      </p>
      <p class="code">
        console.log(1 + "2"); // "12"<br />
        console.log(1 + "2" + 4); // "124"<br />
        console.log(1 + 2 + "4"); // "34"<br />
      </p>
      <h4>Шаблонні рядки</h4>
      <p>
        Шаблонні рядки - це альтернатива конкатенації зі зручнішим синтаксисом.
        Шаблонний рядок береться у зворотні (косі) лапки, замість подвійних або
        одинарних, і може містити заповнювачі місця, які позначаються знаком
        долара і фігурними дужками - ${вираз}.
      </p>
      <p class="code">
        const guestName = "Манго";<br />
        const roomNumber = 207;<br />
        const greeting = `Welcome ${guestName}, your room number is
        ${roomNumber}!`;<br />
        console.log(greeting); // "Welcome Mango, your room number is 207!"
      </p>
      <h4>Властивості і методи рядків</h4>
      <h5>Властивість length.</h5>
      <p class="code">
        const message = "Welcome to Bahamas!";<br />
        console.log(message.length); // 19<br />
        console.log("There is nothing impossible to him who will try".length);
        // 47
      </p>
      <h5>Методи toLowerCase() і toUpperCase()​</h5>
      <p>
        Повертають новий рядок у відповідному регістрі, не змінюючи оригінальний
        рядок.
      </p>
      <p class="code">
        const message = "Welcome to Bahamas!";<br />
        console.log(message.toLowerCase()); // "welcome to bahamas!"<br />
        console.log(message.toUpperCase()); // "WELCOME TO BAHAMAS!"<br />
        console.log(message); // "Welcome to Bahamas!"
      </p>
      <h5>Метод indexOf()​</h5>
      <p>
        Повертає позицію (індекс), на якій знаходиться перший збіг підрядка або
        -1, якщо нічого не знайдено.
      </p>
      <p class="code">
        const message = "Welcome to Bahamas!";<br />
        console.log(message.indexOf("to")); // 8<br />
        console.log(message.indexOf("hello")); // -1
      </p>
      <h5>Метод includes()​</h5>
      <p>
        Перевіряє, чи міститься підрядок в рядку, повертає буль - true, якщо
        міститься, і false - в іншому випадку. Регістр символів в рядку і
        підрядку має значення, оскільки, наприклад, літера "a" не дорівнює
        літері "А".
      </p>
      <p class="code">
        const productName = "Ремонтний дроїд";<br />
        console.log(productName.includes("н")); // true<br />
        console.log(productName.includes("Н")); // false<br />
        console.log(productName.includes("дроїд")); // true<br />
        console.log(productName.includes("Дроїд")); // false<br />
        console.log(productName.includes("Ремонтний")); // true<br />
        console.log(productName.includes("ремонтний")); // false
      </p>
      <h5>Метод endsWith()​</h5>
      <p>
        Дозволяє визначити, чи завершується рядок символами (підрядком),
        зазначеними в дужках, повертаючи true або false.
      </p>
      <p class="code">
        const jsFileName = "script.js";<br />
        console.log(jsFileName.endsWith(".js")); // true<br />
        const cssFileName = "styles.css";<br />
        console.log(cssFileName.endsWith(".js")); // false
      </p>
      <h5>Методи replace() і replaceAll()</h5>
      <p>
        Повертає новий рядок, в якому перше (replace) або усі збіги (replaceAll)
        підрядка замінені на вказане значення.
      </p>
      <p class="code">
        const jsFileName = "script.js";<br />
        const minifiedJsFileName = jsFileName.replace(".js", ".min.js");<br />
        console.log(minifiedJsFileName); // "script.min.js"<br />
        const cssFileNames = "styles.css, about.css, portfolio.css";<br />
        const minifiedCssFileNames = cssFileNames.replaceAll(".css",
        ".min.css");<br />
        console.log(minifiedCssFileNames); // "styles.min.css, about.min.css,
        portfolio.min.css"
      </p>
      <h5>Метод slice()​</h5>
      <p>
        Метод рядків slice (startIndex, endIndex) використовується для створення
        копії частини або всього рядка. Він робить копію елементів рядка від
        startIndex і до, але не включно endIndex і повертає новий рядок, не
        змінюючи оригінал.
      </p>
      <p class="code">
        const productName = "Repair droid";<br />
        console.log(productName.slice(0, 4)); // "Repa"<br />
        console.log(productName.slice(3, 9)); // "air dr"<br />
        console.log(productName.slice(0, productName.length)); // "Repair
        droid"<br />
        console.log(productName.slice(7, productName.length)); // "droid"
      </p>
    </section>
    <h2>Логічні оператори. Розгалуження</h2>
    <section class="section">
      <p>
        Логічні оператори використовуються для перевірки умов з багатьма
        виразами, наприклад в операціях порівняння.
      </p>
      <h3>Приведення типів</h3>
      <p>
        У логічних операціях здійснюється приведення типів операндів до true або
        false. Приведення відбувається, якщо в коді виявлений логічний оператор.
        <br />

        <strong>Truthy і Falsy</strong> - терміни, які використовуються для тих
        значень, які в логічній операції приводяться до true або false, хоча
        спочатку не були булями. <br />
        <strong class="remember">Запам'ятайте:</strong> 6 хибних (falsy)
        значень, що приводяться до false у логічному перетворенні: 0, NaN, null,
        undefined, порожній рядок і false. Абсолютно все інше приводиться до
        true.
      </p>
      <h4>Логічні оператори</h4>
      <p>
        Існує три логічні оператори, які використовуються для перевірки
        виконання множинних виразів.
      </p>
      <img
        src="./img/boolean-operators.png"
        alt="boolean-operators"
        width="320"
      />
      <h5>Логічне «І»​</h5>
      <p>
        Оператор && приводить всі операнди до буля і повертає значення одного з
        них. Лівий операнд - якщо його можна привести до false, і правий - в
        інших випадках. Тобто, логічне «І» зупиняється на хибному і повертає те,
        на чому зупинилось, або останній операнд.
      </p>
      <p class="code">
        console.log(1 && 5); // true && true -> 5 <br />
        console.log(5 && 1); // true && true -> 1<br />
        console.log(0 && 2); // false && true -> 0<br />
        console.log(2 && 0); // true && false -> 0<br />
        console.log("" && "Mango"); // false && true -> ""<br />
        console.log("Mango" && ""); // true && false -> ""<br />
        console.log("Mango" && "Poly"); // true && true -> "Poly"<br />
        console.log("Poly" && "Mango"); // true && true -> "Mango"
      </p>
      <p>
        Виконуючи логічне «І», правий операнд може не обчислюватися у випадку,
        якщо лівий був приведений до false.
      </p>
      <h5>Логічне «АБО»​</h5>
      <p>
        Оператор || приводить всі операнди до буля і повертає значення одного з
        них. Лівий операнд - якщо його можна привести до true, і правий - в
        інших випадках. Тобто, логічне «АБО» зупиняється на правді і повертає
        те, на чому зупинилося або останній операнд.
      </p>
      <p class="code">
        console.log(true || false); // true<br />
        console.log(false || true); // true<br />
        console.log(true || true); // true<br />
        console.log(3 || false); // 3<br />
        console.log(false || 3); // 3<br />
        console.log(3 || true); // 3<br />
        console.log(true || 3); // true<br />
      </p>
      <p>
        Виконуючи логічне «АБО», правий операнд може не обчислюватися у випадку,
        якщо лівий був приведений до true.
      </p>
      <h5>Логічне «НЕ»​</h5>
      <p>
        Логічне «НЕ» - це унарний оператор, який виконує операцію над одним
        операндом з правої сторони. Оператор ! приводить операнд до буля, якщо
        необхідно, а потім робить інверсію - змінює його на протилежний true ->
        false або false -> true.
      </p>
      <p class="code">
        console.log(!true); // false<br />
        console.log(!false); // true<br />
        console.log(!3); // !3 -> !true -> false<br />
        console.log(!"Mango"); // !"Mango" -> !true -> false<br />
        console.log(!0); // !0 -> !false -> true<br />
        console.log(!""); // !"" -> !false -> true<br />
        const isOnline = true; const isNotOnline = !isOnline; // !isOnline ->
        !true -> false
      </p>
    </section>

    <section class="section">
      <h3>Розгалуження</h3>
      <p>
        Розгалуження використовуються для виконання різноманітного коду, залежно
        від умови. Принцип роботи простий - результат умови приводиться до буля
        true або false, після чого потік програми спрямовується в ту або іншу
        гілку.
      </p>
      <h4>Інструкція if​</h4>
      <img src="./img/if.svg" alt="if" width="320" />

      <p>
        Вхідні дані, які приводяться до буля, називаються умовою. Умова
        ставиться після оператора if в круглих дужках. Якщо умова приводиться до
        true, то виконується код у фігурних дужках тіла if.
      </p>
      <pre class="code">
let cost = 0;
const subscription = "pro";

if (subscription === "pro") {
  cost = 100;
}

console.log(cost); // 100
</pre
      >
      <p>
        Якщо умова приводиться до false, код у фігурних дужках буде пропущений.
      </p>
      <pre class="code">
let cost = 0;
const subscription = "free";

if (subscription === "pro") {
  cost = 100;
}

console.log(cost); // 0
</pre
      >
      <h4>Інструкція if...else​</h4>
      <img src="./img/if-else.svg" alt="if-else" width="320" />
      <p>
        Розширює синтаксис if таким чином, що якщо умова приводиться до false,
        виконається код у фігурних дужках після оператора else.
      </p>
      <pre class="code">
let cost;
const subscription = "free";

if (subscription === "pro") {
  cost = 100;
} else {
  cost = 0;
}

console.log(cost); // 0
</pre
      >
      <p>Якщо умова приводиться до true, тіло блока else ігнорується.</p>
      <pre class="code">
let cost;
const subscription = "pro";

if (subscription === "pro") {
  cost = 100;
} else {
  cost = 0;
}

console.log(cost); // 100
</pre
      >

      <h4>Інструкція else...if​</h4>
      <img src="./img/else-if.svg" alt="else-if" width="320" />
      <p>
        Блок else...if дозволяє додати після else ще один оператор if з умовою.
        В кінці ланцюжка може бути класичний блок else, який виконається лише у
        тому випадку, якщо жодна умова не приведеться до true.
      </p>
      <pre class="code">
let cost;
const subscription = "premium";

if (subscription === "free") {
  cost = 0;
} else if (subscription === "pro") {
  cost = 100;
} else if (subscription === "premium") {
  cost = 500;
} else {
  console.log("Invalid subscription type");
}

console.log(cost); // 500
</pre
      >
    </section>
    <section class="section">
      <h3>Тернарний оператор</h3>
      <p>
        Тернарний оператор використовується у якості синтаксично коротшої заміни
        інструкції if...else, коли одній і тій самій змінній необхідно присвоїти
        різні значення за умовою.
      </p>
      <p class="code">
        <умова> ? <вираз_якщо_умова_правдива> : <вираз_якщо_умова_хибна>
      </p>
      <h4>Працює за наступною схемою:</h4>
      <ul class="section-list">
        <li>Обчислюється умова.</li>
        <li>
          Якщо умова правдива, тобто приводиться до true, обчислюється вираз
          після ?.
        </li>
        <li>
          Якщо умова хибна, тобто приводиться до false, обчислюється вираз після
          :.
        </li>
        <li>
          Значення обчисленого виразу повертається у якості результату роботи
          тернарного оператора.
        </li>
      </ul>
      <p class="code">
        const num1 = 5; <br />
        const num2 = 10;<br />
        const biggerNumber = num1 > num2 ? num1 : num2;<br />
        console.log(biggerNumber); // 10<br />
      </p>
    </section>
    <section class="section">
      <h3>Інструкція switch</h3>
      <p>
        Межі застосування switch обмежені задачами з одним загальним запитанням
        (що порівнювати) і рядом варіантів відповідей (з чим порівнювати).
      </p>
      <img src="./img/switch.svg" alt="switch" width="320" />
      <p>
        Його синтаксис складається із блоку <strong>switch(значення)</strong> -
        що потрібно порівняти і набору окремих випадків case значення - з чим
        потрібно порівняти. Для порівняння використовується оператор строгої
        рівності ===. Тобто, не можна порівняти більше або менше, лише рівність.
        Значення в блоці <strong>switch(значення)</strong> - рядок або число,
        яке порівнюється щодо строгої рівності з усіма значеннями в блоках
        <strong>case</strong> значення по черзі, зверху вниз. Оператор
        <strong>break</strong> в кінці кожного блоку
        <strong>case </strong> необхідний, щоб перервати подальші перевірки і
        одразу перейти до коду за <strong>switch</strong> у тому випадку, коли
        перевірка рівності повернула <strong>true</strong>. Якщо жодного збігу
        значень не відбулося, необхідно виконати код за замовчуванням, як і в
        блоці <strong>else</strong> для інструкції <strong>if...else</strong>.
        Для цього, після усіх блоків <strong>case</strong> додається блок
        <strong>default</strong>. Оператор <strong>break</strong> після блоку
        <strong>default</strong> не потрібен, тому що це вже остання операція,
        яка буде виконана в <strong>switch</strong> і управління буде передано
        коду після нього.
      </p>

      <pre class="code">
let cost;
const subscription = "premium";

switch (subscription) {
  case "free":
    cost = 0;
    break;

  case "pro":
    cost = 100;
    break;

  case "premium":
    cost = 500;
    break;

  default:
    console.log("Invalid subscription type");
}

console.log(cost); // 500
</pre
      >
    </section>

    <section class="section">
      <h3>Область видимості</h3>
      <p>
        Область видимості змінних <strong>(variable scope)</strong> -
        доступність змінних в певному місці коду. Глобальна область видимості
        використовується за замовчуванням. Кожен має доступ до змінних,
        оголошених в ній. Наприклад, змінна value оголошена у глобальній області
        видимості, тобто поза будь-яким блоком, і доступна в будь-якому місці
        після оголошення.
      </p>
      <pre class="code">
const value = 5;

if (true) {
  console.log("Block scope: ", value); // 5
}

console.log("Global scope: ", value); // 5
</pre
      >
      <p>
        Будь-яка конструкція, яка використовує фігурні дужки {} (умови, цикли,
        функції тощо), створює нову локальну область видимості, і змінні,
        оголошені в цій області видимості, з використанням let або const, -
        недоступні за межами цього блоку.
      </p>
      <pre class="code">
if (true) {
  const value = 5;
  console.log("Block scope: ", value); // 5
}

console.log("Global scope: ", value); // ReferenceError: value is not defined
</pre
      >
      <p>
        Глибина вкладеності областей видимості - необмежена, і всі вони будуть
        працювати за одним принципом - область видимості має доступ до всіх
        змінних, оголошених вище по ієрархії вкладеності, але не може отримати
        доступ до змінних, оголошених у вкладених областях видимості. Створимо
        декілька областей видимості і дамо їм імена для наочності.
      </p>
      <img src="./img/scope.jpg" alt="scope" width="640" />
      <ul>
        <li>Глобальна область вже присутня, створимо в ній змінну global</li>
        <li>
          Потім, використовуючи оператор if, створимо блочну область видимості
          block A
        </li>
        <li>
          Всередині області видимості block A поставимо ще один оператор if,
          який створить вкладену область видимості block B
        </li>
        <li>
          На одному рівні з block A, створимо область видимості block C, так
          само використовуючи оператор if
        </li>
      </ul>
      <pre class="code">
const global = "global";

if (true) {
  const blockA = "block A";

  // Бачимо глобальну + локальну A
  console.log(global); // 'global'
  console.log(blockA); // block A

  // Змінні blockB і blockC не знайдені в доступних областях видимості.
  // Буде помилка звернення до змінної.
  console.log(blockB); // ReferenceError: blockB is not defined
  console.log(blockC); // ReferenceError: blockC is not defined
  

  if (true) {
    const blockB = "block B";

    // Бачимо глобальну + зовнішню A + локальну B
    console.log(global); // global
    console.log(blockA); // block A
    console.log(blockB); // block B

    // Змінна blockC не знайдена в доступних областях видимості.
    // Буде помилка звернення до змінної.
    console.log(blockC); // ReferenceError: blockC is not defined
  }
}

if (true) {
  const blockC = "block C";

  // Бачимо глобальну + локальну C
  console.log(global); // global
  console.log(blockC); // block C

  // Змінні blockA і blockB не знайдені в доступних областях видимості.
  // Буде помилка звернення до змінної.
  console.log(blockA); // ReferenceError: blockA is not defined
  console.log(blockB); // ReferenceError: blockB is not defined
}

// Бачимо лише глобальну
console.log(global); // global

// Змінні blockA, blockB і blockC не знайдені в доступних областях видимості.
// Буде помилка звернення до змінної.
console.log(blockA); // ReferenceError: blockA is not defined
console.log(blockB); // ReferenceError: blockB is not defined
console.log(blockC); // ReferenceError: blockC is not defined
</pre
      >
    </section>
    <h2>Цикли</h2>
    <section class="section">
      <p>
        Часте завдання програмування - багаторазове виконання однотипної дії.
        Наприклад, вивести клієнтів зі списку один за одним, або перебрати суми
        зарплат, і для кожної виконати однаковий код. Саме для таких цілей -
        багаторазового повторення однієї частини коду, використовуються цикли.
      </p>
      <ul class="section-list">
        <li>
          <strong>Цикл</strong> - керуюча конструкція у високорівневих мовах
          програмування, призначена для організації багаторазового виконання
          набору інструкцій.
        </li>
        <li>
          <strong>Тіло циклу</strong> - послідовність інструкцій, призначена для
          багаторазового виконання.
        </li>
        <li><strong>Ітерація</strong> - одноразове виконання тіла циклу.</li>
        <li>
          <strong>Умова виходу</strong> - вираз, що визначає, чи буде в черговий
          раз виконуватися ітерація, або цикл завершиться.
        </li>
        <li>
          <strong>Лічильник</strong> - змінна, що зберігає поточний номер
          ітерації. Цикл не обов'язково містить лічильник, і він не повинен бути
          один, умова виходу з циклу може залежати від декількох змінних, що
          змінюються в циклі.
        </li>
      </ul>
      <h3>Цикл while​</h3>
      <h4>Цикл з передумовою</h4>
      <p>
        Цикл, який виконується, доки правдива якась умова, зазначена до його
        початку. Ця умова перевіряється до виконання тіла циклу, тому тіло може
        не виконатися жодного разу, якщо умова від самого початку - хибна.
      </p>
      <img src="./img/while.png" alt="while" width="320" />
      <pre class="code">
let counter = 0;

while (counter < 10) {
  console.log("counter: ", counter);
  counter += 1;
}</pre
      >
      <h3>Цикл do...while​​</h3>
      <h4>Цикл з постумовою</h4>
      <p>
        Цикл, в якому умова перевіряється після виконання тіла циклу. З цього
        випливає, що тіло завжди виконується хоча б один раз. Всередині циклу
        потрібно внести зміни в деяку змінну, щоб переконатися, що вираз
        дорівнює false після ітерацій. Інакше буде нескінченний цикл.
      </p>
      <img src="./img/do-while.png" alt="do-while" width="320" />
      <pre class="code">
let password = "";

do {
  password = prompt("Введіть пароль довший 4-х символів", "");
} while (password.length < 5);
        
console.log("Ввели пароль: ", password);</pre
      >
      <h3>Цикл for​</h3>
      <h4>Цикл з лічильником</h4>
      <p>
        Цикл, в якому певна змінна змінює своє значення із заданого початкового
        до кінцевого значення з деяким кроком, і для кожного значення цієї
        змінної тіло циклу виконується один раз. В більшості процедурних мов
        програмування реалізується конструкцією for, в якій зазначається
        лічильник, необхідна кількість ітерацій і крок, з яким змінюється
        лічильник.
      </p>
      <h5>Алгоритм виконання циклу for:</h5>
      <ul class="section-list">
        <li>
          Ініціалізація (initialization) - виконується один раз до початку
          циклу. Використовується для створення змінної-лічильника і зазначення
          її початкового значення.
        </li>
        <li>
          Умова (condition) - вираз, що оцінюється перед кожною ітерацією
          (повторенням) циклу. Тіло циклу виконується тільки тоді, коли вираз
          приводиться до true. Цикл завершується, якщо значення буде false.
        </li>
        <li>
          Тіло (statements) - набір інструкцій для виконання на кожному
          повторенні. Виконується, якщо вираз умови приводиться до true.
        </li>
        <li>
          Пост-вираз (post-expression) - виконується в кінці кожного повторення
          циклу, до перевірки умови. Використовується для оновлення
          змінної-лічильника.
        </li>
      </ul>
      <p>Змінні-лічильники, за традицією, називаються літерами i, j і k.</p>
      <pre class="code">
for (let i = 0; i <= 20; i += 5) {
  console.log(i);
}
</pre
      >
      <pre class="code">
const max = 10;
  for (let i = 0; i < max; i += 1) {
    console.log(`${max} % ${i} = `, max % i);
  }</pre
      >
      <h5>Оператор break​</h5>
      <p>
        Перервати виконання циклу можна в будь-який момент. Для цього існує
        оператор break, який повністю припиняє виконання циклу і передає
        управління на рядок після його тіла. Знайдемо число 3. Щойно виконається
        умова if, цикл припинить своє виконання (буде перерваний).
      </p>
      <pre class="code">
for (let i = 0; i <= 5; i += 1) {
  console.log(i);

  if (i === 3) {
    console.log("Знайшли число 3, перериваємо виконання циклу");
    break;
  }
}

console.log("Лог після циклу");
</pre
      >
      <h5>Оператор continue​</h5>
      <p>
        Перериває не увесь цикл, а тільки виконання поточної ітерації. Його
        використовують, якщо зрозуміло, що на поточній ітерації циклу більше
        немає що робити або взагалі не потрібно нічого робити, і час переходити
        до наступної ітерації. Використовуємо цикл для введення тільки непарних
        чисел. Для парних i спрацьовує continue, виконання тіла припиняється і
        управління передається до наступної ітерації.
      </p>
      <pre class="code">
const number = 10;

  for (let i = 0; i < number; i += 1) {
    if (i % 2 === 0) {
      continue;
    }
  
    console.log("Непарне i: ", i); // 1, 3, 5, 7, 9
  }</pre
      >
    </section>
    <section class="section">
      <h3>Заголовок</h3>
      <p>
        Lorem ipsum dolor sit amet consectetur adipisicing elit. Distinctio
        reprehenderit obcaecati harum, dolor a, itaque deleniti dolorem eaque
        deserunt sunt dolore ratione culpa, magnam officia quisquam? Harum,
        eaque ullam! Aperiam. Nisi illum eveniet ad, animi eius rerum.
        Repudiandae nemo iure fugiat architecto blanditiis dolor consequuntur at
        explicabo tenetur accusamus mollitia, debitis aliquam aut exercitationem
        quos doloremque repellendus quis assumenda deserunt!
      </p>
    </section>
  </body>
</html>
