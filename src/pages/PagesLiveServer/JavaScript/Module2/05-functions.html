<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Функції</title>
    <link rel="stylesheet" href="../css/styles.css" />
  </head>
  <body>
    <a href="../../../../indexLS.html">Home</a>

    <h2>Функції</h2>

    <section class="section">
      <p>
        <strong>Функція</strong> - це підпрограма, незалежна частина коду,
        призначена для багаторазового виконання конкретної задачі з різними
        початковими значеннями. Функції дозволяють структурувати великі
        програми, зменшують повторення та ізолюють код.
      </p>
      <h4>Function declaration</h4>
      <p>
        <strong>Оголошення функції (function declaration)</strong> починається з
        ключового слова function, після якого стоїть ім'я - дієслово, що
        відповідає на запитання «Що зробити?» і пара круглих дужок. Тіло функції
        береться у фігурні дужки {} і містить інструкції, які необхідно виконати
        на момент її виклику. Потім, коли необхідно, функція викликається за
        допомогою імені і пари круглих дужок.
      </p>
      <h5>Параметри та аргументи</h5>
      <p>
        В круглих дужках після імені функції зазначаються параметри - перелік
        даних, які функція очікує на момент виклику.
      </p>
      <pre class="code">
// Оголошення параметрів x, y, z
function multiply(x, y, z) {
  console.log(`Результат множення дорівнює ${x * y * z}`);
}
</pre
      >
      <p>
        <strong>Параметри</strong> - це локальні змінні, доступні тільки у тілі
        функції. Вони розділяються комами. Параметрів може бути декілька, або
        взагалі не бути, у такому випадку записуються просто порожні круглі
        дужки. Параметри будуть створюватися кожного разу під час виконання
        функції, і їх окремі інкарнації жодним чином один з одним не пов'язані.
      </p>
      <p>
        На момент виклику функції, в круглих дужках можна передати
        <strong>аргументи</strong> - значення для оголошених параметрів функції.
      </p>
      <pre class="code">
// 1. Оголошення параметрів x, y, z
function multiply(x, y, z) {
  console.log(`Результат множення дорівнює ${x * y * z}`);
}
        
// 2. Передача аргументів
multiply(2, 3, 5); // Результат множення дорівнює 30
multiply(4, 8, 12); // Результат множення дорівнює 384
multiply(17, 6, 25); // Результат множення дорівнює 2550
</pre
      >
      <p>
        Порядок передачі аргументів повинен відповідати порядку оголошених
        параметрів: значення першого аргументу буде присвоєно першому параметру,
        другого аргументу - другому параметру тощо. Якщо параметрів буде більше,
        ніж аргументів, то параметрам без значень буде присвоєно undefined.
      </p>
      <h5>Повернення значення</h5>
      <p>
        Оператор <strong>return</strong> використовується для передачі значення
        з тіла функції у зовнішній код. Коли інтерпретатор зустрічає
        <strong>return</strong>, він відразу ж виходить з функції (припиняє її
        виконання), і повертає вказане значення у те місце коду, де була
        викликана функція.
      </p>
      <pre class="code">
function multiply(x, y, z) {
  console.log("Код до return виконується звичайним чином");

  // Повертаємо результат виразу множення
  return x * y * z;

  console.log("Цей лог ніколи не виконається, він стоїть після return");
}

// Результат роботи функції можна зберегти у змінну
let result = multiply(2, 3, 5);
console.log(result); // 30

result = multiply(4, 8, 12);
console.log(result); // 384

result = multiply(17, 6, 25);
console.log(result); // 2550
</pre
      >
      <p>
        Оператор return без явно вказаного значення повертає спеціальне значення
        undefined. За відсутності return в тілі функції, вона все одно поверне
        undefined.
      </p>

      <h5>Порядок виконання коду</h5>
      <p>
        Коли інтерпретатор зустрічає виклик функції (або методу), він призупиняє
        виконання поточного коду і починає виконувати код з тіла функції. Після
        того як увесь код функції буде виконаний, інтерпретатор виходить з тіла
        функції, повертаючись у те місце, звідки прийшов, і продовжує виконувати
        код, наступний після виклику функції.
      </p>
      <pre class="code">
function multiply(x, y, z) {
  console.log(`Результат множення дорівнює ${x * y * z}`);
}

console.log("Лог до виклику функції multiply");
multiply(2, 3, 5); // Результат множення дорівнює 30
console.log("Лог після виклику функції multiply");

// Послідовність логів в консолі
// "Лог до виклику функції multiply"
// "Результат множення дорівнює 30"
// "Лог після виклику функції multiply"
</pre
      >
      <h5>Параметри за замовчуванням</h5>
      <p>
        Іноді необхідно оголосити функцію, у параметрів якої будуть значення,
        відмінні від <strong>undefined</strong> , навіть якщо для них не
        передали аргументи. Це робиться дуже простим та очевидним чином -
        достатньо вказати значення за замовчуванням безпосередньо на момент
        оголошення параметрів у підписі функції. У випадку такого запису, якщо
        для параметра не було передано значення аргументу, використовується
        значення за замовчуванням.
      </p>
      <pre class="code">
function count(countFrom = 0, countTo = 10, step = 1) {
  console.log(`countFrom = ${countFrom}, countTo = ${countTo}, step = ${step}`);

  for (let i = countFrom; i <= countTo; i += step) {
    console.log(i);
  }
}

count(1, 5); // countFrom = 1, countTo = 5, step = 1
count(2); // countFrom = 2, countTo = 10, step = 1
count(); // countFrom = 0, countTo = 10, step = 1
</pre
      >
      <h5>Псевдомасив arguments​</h5>
      <p>
        Доступ до списку всіх аргументів можна отримати за допомогою спеціальної
        змінної <strong>arguments</strong> , яка доступна тільки всередині
        функції і зберігає всі аргументи у якості псевдомасиву.

        <strong>Псевдомасив</strong> - колекція з властивістю
        <strong>length</strong> і можливістю звернутися до елементу за індексом,
        але відсутністю більшості методів для роботи з масивом. Розглянемо
        приклад використання arguments у функції, яка множить будь-яку кількість
        аргументів:
      </p>
      <pre class="code">
function multiply() {
  let total = 1;

  for (const argument of arguments) {
    total *= argument;
  }

  return total;
}

console.log(multiply(1, 2, 3)); //  6
console.log(multiply(1, 2, 3, 4)); //  24
console.log(multiply(1, 2, 3, 4, 5)); //  120
</pre
      >

      <h5>Перетворення псевдомасиву</h5>
      <p>
        Зазвичай псевдомасив необхідно перетворити у повноцінний масив, оскільки
        у псевдомасиву відсутні методи масиву, наприклад
        <strong>slice()</strong> або <strong>includes()</strong>. На практиці
        застосовують декілька основних способів. Використовуючи метод
        <strong>Array.from()</strong>, який створить масив із псевдомасиву.
      </p>
      <pre class="code">
function fn() {
  // Змінна args буде містити повноцінний масив
  const args = Array.from(arguments);
}
</pre
      >
      <p>
        Використовуючи операцію <strong>... (rest)</strong>, вона дозволяє
        зібрати будь-яку кількість елементів, у нашому випадку аргументів, в
        масив, і зберегти його в змінну. Збираємо всі аргументи, використовуючи
        операцію <strong>rest</strong>
        безпосередньо в підписі функції.
      </p>
      <pre class="code">
function fn(...args) {
  // Змінна args буде містити повноцінний масив
}
</pre
      >
      <h5>Патерн «Раннє повернення»</h5>
      <p>
        Оператор <strong>if...else</strong> - це основний спосіб створення
        розгалужень. Проте, складні вкладені розгалуження роблять код заплутаним
        для розуміння. Створимо функцію, яка обробляє зняття коштів з особистого
        рахунку в банку. Вона отримує суму для зняття і поточний баланс рахунку,
        після чого, залежно від умови, виконує необхідний блок коду.
      </p>
      <pre class="code">
function withdraw(amount, balance) {
  if (amount === 0) {
    console.log("Для проведення операції введіть суму більшу за нуль");
  } else if (amount > balance) {
    console.log("Недостатньо коштів на рахунку");
  } else {
    console.log("Операція зняття коштів проведена успішно");
  }
}

withdraw(0, 300); // "Для проведення операції введіть суму більшу за нуль"
withdraw(500, 300); // "Недостатньо коштів на рахунку"
withdraw(100, 300); // "Операція зняття коштів проведена успішно"
</pre
      >
      <p>
        Навіть у такому простому прикладі є група вкладених умовних операторів,
        серед яких не одразу можна зрозуміти логіку виконання коду. У функції
        може бути більше одного оператора return. Головне пам'ятати, що
        виконання функції переривається, коли інтерпретатор зустрічає
        повернення, і увесь код після нього буде проігнорований в поточному
        виконанні функції.

        <strong>Патерн «Раннє повернення»</strong> - це спосіб використовувати
        можливість дострокового повернення з функції за допомогою оператора
        return. Використовуючи цей прийом, ми отримуємо чистіший, плоскіший і
        зрозуміліший код, який простіше рефакторити. Виділимо всі перевірки умов
        в окремі оператори <strong>if</strong>, після чого додамо код, що
        знаходиться в тілі <strong>else</strong>. В ідеальному випадку, повинен
        вийти плоский список умовних операторів, що йдуть один за одним, а в
        кінці - блок, який виконається тільки у тому випадку, якщо не
        виконається жоден <strong>if</strong>.
      </p>
      <pre class="code">
function withdraw(amount, balance) {
  // Якщо умова виконується, викликається console.log
  // і вихід із функції. Код після тіла if не виконається.
  if (amount === 0) {
    console.log("Для проведення операції введіть суму більшу за нуль");
    return;
  }

  // Якщо умова першого if не виконалась, його тіло пропускається
  // та інтерпретатор доходе до другого if.
  // Якщо умова виконується, викликається console.log і вихід із функції.
  // Код, що знаходиться після тіла if, не виконається.
  if (amount > balance) {
    console.log("Недостатньо коштів на рахунку");
    return;
  }

  // Якщо жоден із попередніх if не виконався,
  // інтерпретатор доходить до цього коду і виконує його.
  console.log("Операція зняття коштів проведена");
}

withdraw(0, 300); // "Для проведення операції введіть суму більшу за нуль"
withdraw(500, 300); // "Недостатньо коштів на рахунку"
withdraw(100, 300); // "Операція зняття коштів проведена"
</pre
      >
      <h4>Функціональний вираз</h4>
      <p>
        <strong>Функціональний вираз (function expression)</strong> - звичайне
        оголошення змінної, значенням якої буде функція. Альтернативний спосіб
        оголошення функції.
      </p>
      <pre class="code">
// Оголошення функції (function declaration)
  function multiply(x, y, z) {
    console.log(`Результат множення дорівнює ${x * y * z}`);
  }
  
  // Функціональний вираз (function expression)
  const multiply = function (x, y, z) {
    console.log(`Результат множення дорівнює ${x * y * z}`);
  };
  </pre
      >
      <p>
        Різниця в тому, що функціональний вираз не можна викликати до місця його
        створення, тільки після нього, тому що це буквально оголошення const
        змінної.
      </p>
      <pre class="code">
// ❌ Помилка! Не працює виклик до оголошення
  multiply(1, 2, 3);
  
  const multiply = function (x, y, z) {
    console.log(`Результат множення дорівнює ${x * y * z}`);
  };
  
  // ✅ Працює виклик після оголошення
  multiply(4, 5, 6);
  </pre
      >
      <p>A оголошення функції можна викликати до місця її створення в коді.</p>
      <pre class="code">
// ✅ Працює виклик до оголошення
  multiply(1, 2, 3);
  
  function multiply(x, y, z) {
    console.log(`Результат множення дорівнює ${x * y * z}`);
  }
  
  // ✅ Працює виклик після оголошення
  multiply(4, 5, 6);
  </pre
      >
      <p>
        Не важливо, який синтаксис використовувати, важливо, щоб код в проекті
        був однорідним. Тобто необхідно намагатися не змішувати оголошення
        функції з функціональними виразами.
      </p>
    </section>

    <!-- ! -->
    <button class="accordion">Завдання</button>
    <div class="panel">
      <pre><code class="language-js">
Відповідь
</code></pre>
    </div>
    <!-- ! -->
    <button class="accordion">Завдання</button>
    <div class="panel">
      <pre><code class="language-js">
Відповідь
</code></pre>
    </div>
    <!-- ! -->
    <button class="accordion">Завдання</button>
    <div class="panel">
      <pre><code class="language-js">
Відповідь
</code></pre>
    </div>
    <!-- ! -->
    <button class="accordion">Завдання</button>
    <div class="panel">
      <pre><code class="language-js">
Відповідь
</code></pre>
    </div>
    <!-- ! -->
    <button class="accordion">Завдання</button>
    <div class="panel">
      <pre><code class="language-js">
Відповідь
</code></pre>
    </div>

    <!-- ! -->
    <button class="accordion">Завдання</button>
    <div class="panel">
      <pre><code class="language-js">
Відповідь
</code></pre>
    </div>
    <!-- ! -->
    <button class="accordion">Завдання</button>
    <div class="panel">
      <pre><code class="language-js">
Відповідь
</code></pre>
    </div>

    <script src="../js/main.js" type="module"></script>
  </body>
</html>
