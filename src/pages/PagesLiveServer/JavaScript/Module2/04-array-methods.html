<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Методи масиву</title>
    <link rel="stylesheet" href="../css/styles.css" />
  </head>
  <body>
    <a href="../../../../indexLS.html">Home</a>

    <h2>Методи масиву</h2>

    <section class="section">
      <h4>Методи split() і join()​</h4>
      <p>
        <strong>Метод split(delimiter) </strong> перетворює рядок в масив,
        «розбиваючи» його роздільником delimiter. Якщо роздільник - це порожній
        рядок, то створиться масив окремих символів. Роздільником може бути один
        або декілька символів.
      </p>
      <pre class="code">
const name = "Mango";
console.log(name.split("")); // ["M", "a", "n", "g", "o"]
        
const message = "JavaScript - це цікаво";
console.log(message.split(" ")); // ["JavaScript", "-", "це", "цікаво"]
        </pre
      >
      <p>
        <strong>Метод join(delimiter)</strong> об'єднує елементи масиву у рядок.
        У рядку елементи будуть розділені символом або групою символів,
        зазначених в delimiter. Тобто ця операція протилежна методу рядків
        split(delimiter).
      </p>
      <pre class="code">
const words = ["JavaScript", "це", "цікаво"];
console.log(words.join("")); // "JavaScriptцецікаво"
console.log(words.join(" ")); // "JavaScript це цікаво"
console.log(words.join("-")); // "JavaScript-це-цікаво"
</pre
      >
      <h4>Метод indexOf()​</h4>
      <p>
        <strong>indexOf(value)</strong> повертає перший індекс, в якому елемент
        зі значенням value був знайдений в масиві, або число -1, якщо такий
        елемент відсутній. Використовуйте indexOf тоді, коли необхідно отримати
        сам індекс елемента.
      </p>
      <pre class="code">
const clients = ["Mango", "Ajax", "Poly", "Kiwi"];
console.log(clients.indexOf("Poly")); // 2
console.log(clients.indexOf("Monkong")); // -1
</pre
      >
      <h4>Метод includes()​</h4>
      <p>
        <strong>includes(value)</strong> перевіряє, чи містить масив елемент зі
        значенням value і повертає true або false відповідно. Застосування цього
        методу корисне в ситуаціях, коли необхідно перевірити, чи є елемент в
        масиві і не важлива його позиція (індекс).
      </p>
      <pre class="code">
const clients = ["Mango", "Ajax", "Poly", "Kiwi"];
console.log(clients.includes("Poly")); // true
console.log(clients.includes("Monkong")); // false
</pre
      >
      <p>Перевірка багатьох умов з includes()​</p>
      <pre class="code">
// Виносимо варіанти в масив
const redFruits = ["apple", "strawberry", "cherry", "cranberries"];
const fruit = "cherry";
// Перевіряємо присутність елемента
const hasFruit = redFruits.includes(fruit);
  
if (hasFruit) {
  console.log(`${fruit} is a red fruit!`);
}
</pre
      >
      <h4>Методи push() і pop()​</h4>
      <p>
        Додають або видаляють крайні елементи масиву. Працюють тільки з крайнім
        лівим і крайнім правим елементом, і не можуть вставити або видалити
        елемент з довільної позиції.
      </p>
      <p>
        <strong>Метод push()</strong> додає один або декілька елементів
        наприкінці масиву, без необхідності зазначати індекси елементів, що
        додаються. Повертає довжину масиву після додавання елементів.
      </p>
      <pre class="code">
const numbers = [];

numbers.push(1);
console.log(numbers); // [1]
  
numbers.push(2);
console.log(numbers); // [1, 2]
  
numbers.push(3);
console.log(numbers); // [1, 2, 3]
  
numbers.push(4);
console.log(numbers); // [1, 2, 3, 4]
  
numbers.push(5);
console.log(numbers); // [1, 2, 3, 4, 5]
  </pre
      >
      <p>
        Метод pop() видаляє останній елемент з кінця масиву і повертає видалений
        елемент. Якщо масив порожній, метод повертає undefined.
      </p>
      <pre class="code">
const numbers = [1, 2, 3, 4, 5];

console.log(numbers.pop()); //  5
console.log(numbers); // [1, 2, 3, 4]
  
console.log(numbers.pop()); //  4
console.log(numbers); // [1, 2, 3]
  
console.log(numbers.pop()); //  3
console.log(numbers); // [1, 2]
  
console.log(numbers.pop()); //  2
console.log(numbers); // [1]
  
console.log(numbers.pop()); //  1
console.log(numbers); // []
</pre
      >
      <h4>Метод slice()​</h4>
      <p>
        <strong>slice(begin, end)</strong> повертає новий масив, що містить
        копію частини вихідного масиву, не змінюючи його. Копія створюється з
        begin і до, але не включно, end - індекси елементів вихідного масиву.
      </p>
      <pre class="code">
const clients = ["Mango", "Ajax", "Poly", "Kiwi"];
console.log(clients.slice(1, 3)); // ["Ajax", "Poly"]
</pre
      >
      <p>
        Якщо begin і end не зазначені, буде створена повна копія вихідного
        масиву.
      </p>
      <pre class="code">
const clients = ["Mango", "Ajax", "Poly", "Kiwi"];
console.log(clients.slice()); // ["Mango", Ajax", "Poly", "Kiwi"]
  </pre
      >
      <p>
        Якщо не зазначено end, копіювання буде зі start і до кінця вихідного
        масиву.
      </p>
      <pre class="code">
const clients = ["Mango", "Ajax", "Poly", "Kiwi"];
console.log(clients.slice(1)); // ["Ajax", "Poly", "Kiwi"]
console.log(clients.slice(2)); // ["Poly", "Kiwi"]
</pre
      >
      <p>
        Якщо значення start від'ємне, а end не зазначено - будуть скопійовані
        останні start елементи
      </p>
      <pre class="code">
const clients = ["Mango", "Ajax", "Poly", "Kiwi"];
console.log(clients.slice(-2)); // ["Poly", "Kiwi"]
</pre
      >
      <h4>Метод splice()​</h4>
      <p>
        Швейцарський ніж для роботи з масивами, якщо вихідний масив необхідно
        змінити. Видаляє, додає і замінює елементи у довільному місці масиву.
      </p>

      <h5>Видалення​</h5>
      <p>Щоб видалити елементи в масиві, передаються два аргументи.</p>

      <pre class="code">
splice(position, num)
</pre
      >
      <ul class="section-list">
        <li>
          position - вказує на позицію (індекс) першого елемента для видалення
        </li>
        <li>
          position - вказує на позицію (індекс) першого елемента для видалення
        </li>
      </ul>
      <p>
        <strong>Метод splice</strong> змінює вихідний масив і повертає масив, що
        містить видалені елементи. Наприклад, у нас є масив оцінок, який містить
        п'ять чисел від 1 до 5.
      </p>
      <pre class="code">
const scores = [1, 2, 3, 4, 5];

// Видаляємо три елементи масиву, починаючи з першого елемента (індекс 0)
const deletedScores = scores.splice(0, 3);
        
// Тепер масив scores містить два елементи
console.log(scores); // [4, 5]
        
// А масив deletedScores містить три видалені елементи
console.log(deletedScores); // [1, 2, 3]
</pre
      >
      <h5>Додавання</h5>
      <p>
        Для того, щоб додати один або декілька елементів в масив, необхідно
        передати три або більше аргументи, за такої умови, другий аргумент
        повинен дорівнювати нулю.
      </p>
      <pre class="code">
splice(position, 0, new_element_1, new_element_2, ...)
</pre
      >
      <ul class="section-list">
        <li>
          Аргумент position вказує початкову позицію в масиві, куди будуть
          вставлені нові елементи.
        </li>
        <li>
          Другий аргумент - це нуль, він говорить методу не видаляти елементи в
          місці додавання нових.
        </li>
        <li>
          Третій, четвертий і всі наступні аргументи - це нові елементи, які
          додаються в масив.
        </li>
      </ul>
      <p>
        Наприклад, у нас є масив з назвами кольорів у вигляді рядків. Додамо
        новий колір перед елементом з індексом 2.
      </p>
      <pre class="code">
const colors = ["red", "green", "blue"];

colors.splice(2, 0, "purple");
console.log(colors); // ["red", "green", "purple", "blue"]
</pre
      >
      <p>
        Можна додати довільну кількість елементів, передавши четвертий, п'ятий
        аргумент тощо.
      </p>
      <pre class="code">
const colors = ["red", "green", "blue"];

colors.splice(1, 0, "yellow", "pink");
console.log(colors); // ["red", "yellow", "pink", "green", "blue"]
</pre
      >
      <h5>Заміна</h5>
      <p>
        <strong>Заміна</strong> - це операція додавання, в якій видаляються
        елементи в місці додавання нових. Для цього необхідно передати мінімум
        три аргументи. Кількість елементів, що видаляються і додаються, може не
        збігатися.
      </p>
      <pre class="code">
splice(position, num, new_element_1, new_element_2, ...)
</pre
      >
      <ul class="section-list">
        <li>
          <strong>position</strong> - вказує на позицію (індекс) першого
          елемента для видалення
        </li>
        <li>
          <strong>num</strong> - визначає кількість елементів, що видаляються
        </li>
        <li>
          Третій, четвертий і всі наступні аргументи - це нові елементи, які
          додаються в масив.
        </li>
      </ul>
      <p>Наприклад, у нас є масив мов програмування з чотирьох елементів.</p>
      <pre class="code">
const languages = ["C", "C++", "Java", "JavaScript"];

// Заміняємо елемент з індексом 1 на новий
languages.splice(1, 1, "Python");
console.log(languages); // ["C", "Python", "Java", "JavaScript"]
  
// Заміняємо один елемент (з індексом 2) на декілька
languages.splice(2, 1, "C#", "Swift", "Go");
console.log(languages); // ["C", "Python", "C#", "Swift", "Go", "JavaScript"]
</pre
      >
      <h5>Метод concat()​</h5>
      <p>
        Об'єднує два або більше масивів в один. Він не змінює масив, на якому
        викликається, а повертає новий. Порядок аргументів методу впливає на
        порядок елементів нового масиву.
      </p>
      <pre class="code">
const oldClients = ["Mango", "Ajax", "Poly", "Kiwi"];
const newClients = ["Monkong", "Singu"];
  
const allClientsWithOldFirst = oldClients.concat(newClients);
console.log(allClientsWithOldFirst); // ["Mango", "Ajax", "Poly", "Kiwi", "Monkong", "Singu"]
  
const allClientsWithNewFirst = newClients.concat(oldClients);
console.log(allClientsWithNewFirst); // ["Monkong", "Singu", "Mango", "Ajax", "Poly", "Kiwi"]
  
console.log(oldClients); // ["Mango", "Ajax", "Poly", "Kiwi"]
console.log(newClients); // ["Monkong", "Singu"]
</pre
      >
    </section>

    <!-- ! -->
    <button class="accordion">Завдання</button>
    <div class="panel">
      <pre><code class="language-js">
Відповідь
</code></pre>
    </div>
    <!-- ! -->
    <button class="accordion">Завдання</button>
    <div class="panel">
      <pre><code class="language-js">
Відповідь
</code></pre>
    </div>
    <!-- ! -->
    <button class="accordion">Завдання</button>
    <div class="panel">
      <pre><code class="language-js">
Відповідь
</code></pre>
    </div>
    <!-- ! -->
    <button class="accordion">Завдання</button>
    <div class="panel">
      <pre><code class="language-js">
Відповідь
</code></pre>
    </div>
    <!-- ! -->
    <button class="accordion">Завдання</button>
    <div class="panel">
      <pre><code class="language-js">
Відповідь
</code></pre>
    </div>

    <!-- ! -->
    <button class="accordion">Завдання</button>
    <div class="panel">
      <pre><code class="language-js">
Відповідь
</code></pre>
    </div>
    <!-- ! -->
    <button class="accordion">Завдання</button>
    <div class="panel">
      <pre><code class="language-js">
Відповідь
</code></pre>
    </div>

    <script src="../js/main.js" type="module"></script>
  </body>
</html>
