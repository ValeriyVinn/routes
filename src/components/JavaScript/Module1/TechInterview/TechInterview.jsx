import css from './TechInterview.module.css'
const TechInterview = () => {
  return (
    <>
      <h5>Які типи даних присутні в JavaScript?</h5>
      <ul>
        <li className={css.uk}>        Існує 8 типів даних. 7 примітивних та 1 складний тип даних. Примітивні
        типи: number, string, boolean, symbol, bigInt, null, undefined. Складний
        тип - object. Він використовується для колекцій даних та для оголошення
        більш складних сутностей. Також він передається за посиланням, а прості
        типи даних за значенням.</li>
        <li className={css.en}>There are eight data types. Seven primitive and one complex data type. Primitive types: number, string, boolean, symbol, bigInt, null, undefined. Complex type - object. It is used for collections of data and for declaring more complex entities. It is also passed by reference, and simple data types by value.</li>
        <li className={css.tr}>ðɛr ɑr eɪt deɪtə taɪps. sɛvən prɪmətɪv ænd wʌn kɑmplɛks deɪtə taɪp. prɪmətɪv taɪps: nʌmbər, strɪŋ, buliən, sɪmbəl, bɪɡˌɪnt, nʌl, ʌndɪfaɪnd. kɑmplɛks taɪp - ɑbdʒɛkt. ɪt ɪz juzd fɔr kəˈlɛkʃənz ʌv deɪtə ænd fɔr dɪˈklɛrɪŋ mɔr kɑmplɛks ɛntɪtiz. ɪt ɪz ɔlsoʊ pæst baɪ rɛfərəns, ænd sɪmpəl deɪtə taɪps baɪ vælju.</li>
      </ul>
      <p className={css.uk}>
        Існує 8 типів даних. 7 примітивних та 1 складний тип даних. Примітивні
        типи: number, string, boolean, symbol, bigInt, null, undefined. Складний
        тип - object. Він використовується для колекцій даних та для оголошення
        більш складних сутностей. Також він передається за посиланням, а прості
        типи даних за значенням.
      </p>
      <p className={css.en}>There are eight data types. Seven primitive and one complex data type. Primitive types: number, string, boolean, symbol, bigInt, null, undefined. Complex type - object. It is used for collections of data and for declaring more complex entities. It is also passed by reference, and simple data types by value.</p>
      <p className={css.tr}>
ðɛr ɑr eɪt deɪtə taɪps. sɛvən prɪmətɪv ænd wʌn kɑmplɛks deɪtə taɪp. prɪmətɪv taɪps: nʌmbər, strɪŋ, buliən, sɪmbəl, bɪɡˌɪnt, nʌl, ʌndɪfaɪnd. kɑmplɛks taɪp - ɑbdʒɛkt. ɪt ɪz juzd fɔr kəˈlɛkʃənz ʌv deɪtə ænd fɔr dɪˈklɛrɪŋ mɔr kɑmplɛks ɛntɪtiz. ɪt ɪz ɔlsoʊ pæst baɪ rɛfərəns, ænd sɪmpəl deɪtə taɪps baɪ vælju.</p>
      <h5>Що таке NaN?</h5>
      <p>
        NaN (not a number) - це значення, що отримується в результаті виконання
        числової операції над не числовим значенням. Його тип даних number. NaN
        не дорівнює самому собі. Перевірку на NaN можна зробити за допомогою
        Number.isNaN
      </p>
      <h5>Яка різниця між null та undefined?</h5>
      <p>
        undefined (невизначений) являє собою значення за замовчуванням: 1 -
        змінної, яку оголосили без ініціалізації; 2 - функції, яка нічого не
        повертає явно; 3 - неіснуючої властивості об'єкта. null - це значення
        «відсутності значення». Присвоюється змінній явно.
      </p>
      <h5>Чим відрізняється строга і нестрога рівність (=== та ==)?</h5>
      <p>
        Строга рівність порівнює значення за типом даних та значенням. Нестрогa
        приводить значення до одного типу, а потім ці значення порівнює.
      </p>
      <h5>Чому результатом порівняння двох схожих об'єктів є false?</h5>
      <p>
        Тому що об'єкти - це типи даних, що передаються за посиланням. 2
        однакові на вигляд об'єкта мають різні посилання, і тому операція
        порівняння повертатиме false.
      </p>
      <h5>Як перевірити 2 об'єкти на ідентичність?</h5>
      <p>
        1 - використовувати JSON.stringify для приведення об'єктів у рядок та
        порівняти їх вже як 2 рядки. Такий підхід має обмеження. Якщо в об'єкті
        будуть методи або symbol - JSON.stringify не зможе конвертувати їх у
        рядок. 2 - написати або використати з бібліотеки функцію deepEqual, яка
        буде проходити циклом по ключах двох об'єктів і перевірятиме значення
        цих ключів. Функція має працювати рекурсивно.
      </p>
      <h5>Як зробити копію об'єкта?</h5>
      <p>
        Існує поняття глибокого та поверхневого копіювання. Глибоке - це
        копіювання об'єкта та всіх його рівнів вкладеності. Поверхневе - це
        копіювання лише першого рівня вкладеності, а для решти копіюється
        посилання. Способи поверхневого копіювання: 1 - використовувати spread
        оператор (...) 2 - використовувати Object.assign() Способи глибокого
        копіювання: 1 - використовувати JSON.stringify - JSON.parse для
        конвертування об'єкта в рядок і потім назад. Має обмеження щодо
        копіювання методів та symbols 2 - написати або використати з бібліотеки
        функцію deepClone яка буде рекурсивно проходитиме за ключами об'єкта та
        копіюватиме їх у новий об'єкт.
      </p>
      <h5>Чим відрізняються змінні var, let та const?</h5>
      <p>
        var - змінну можна ініціалізувати після оголошення, можна змінювати, має
        функціональну область видимості, має hoisting. Зараз майже не
        використовують під час написання нового коду. let - змінну можна
        ініціалізувати після оголошення, можна змінювати, має блокову область
        видимості, не має hoisting. const - змінну обов'язково потрібно
        ініціалізувати під час оголошення, не можна змінювати, має блокову
        область видимості, не має hoisting.
      </p>
      <h5>Як дізнатися чи є об'єкт масивом?</h5>
      <p>Для цього можна використати метод Array.isArray.</p>
      <h5>Які перебираючі методи масивів ви знаєте?</h5>
      <p>
        Є такі методи:
        <br />
        - forEach – для перебору масиву.
        <br />
        - filter – для фільтрації масиву.
        <br />
        - every/some – для перевірки масиву.
        <br />
        - map – для трансформації масиву в масив.
        <br />
        - reduce/reduceRight – для проходу по масиву з обчисленням значення.
        <br />- sort - сортує масив.
      </p>
      <h5>Як об'єднати масиви?</h5>
      <p>
        1 - Можна використовувати метод concat(). 2 - Можна використовувати
        spread оператор та об’єднати ці масиви в один загальний масив.
      </p>
      <h5>Як дізнатися чи знаходиться елемент у масиві?</h5>
      <p>
        1 - Використати метод includes, який повертає true якщо елемент
        знаходиться у масиві. 2 - Використати метод indexOf який повертає індекс
        знайденого елемента в масиві або -1 якщо елемента в масиві немає. 3 -
        також можна використати метод find, який повертає знайдений елемент, або
        повертає undefined.
      </p>
      <h5>Що таке підняття (hoisting)?</h5>
      <p>
        Це механізм у JavaScript, в якому змінні типу var та оголошення функцій,
        пересуваються вгору своєї області видимості перед тим, як код буде
        виконаний.
      </p>
      <h5>
        Яким буде значення змінної var, якщо звернутися до неї до її оголошення?
      </h5>
      <p>Значенням змінної буде undefined.</p>
      <h5>Що буде, якщо звернутися до змінної let/const до її оголошення?</h5>
      <p>Буде помилка типу ReferenceError. Змінної ще не існує.</p>
      <h5>Що таке область видимості (Scope)?</h5>
      <p>
        Це місце, де (або звідки) ми маємо доступ до змінних або функцій. JS має
        4 типи областей видимості: глобальна, функціональна, блокова (ES6) та
        область видимості eval.
      </p>
      <h5>Чим Function Declaration відрізняється від Function Expression?</h5>
      <p>
        Function Expression створюється, коли виконання доходить до нього, а
        потім вже може використовуватися. Function Declaration можна
        використовувати у всьому скрипті (або блоці коду, якщо функцію оголошено
        в блоці).
      </p>
      <h5>Чим стрілочна функція відрізняється від звичайної?</h5>
      <p>
        Стрілочна функція не має власного this. Вона бере його за місцем
        створення. У звичайній функції this визначається під час виклику.
        Стрілочна функція не має arguments. Стрілочна функція не має prototype.
        Стрілочна функція має короткий синтаксис неявного повернення значення.
      </p>
      <h5>Чи існує аналог arguments для стрілочної функції?</h5>
      <p>
        Аналога немає. Але можна використовувати rest оператор (...) для того,
        щоб зібрати всі параметри з якими викликана функція в масив.
      </p>
      <h5>Відповіді на: Що таке лексичне оточення (Lexical Environment)?</h5>
      <p>
        Це властивості внутрішнього об'єкта функції, які створюються під час її
        виклику. Туди записуються аргументи, функції та змінні. Також там
        знаходиться посилання на зовнішнє лексичне оточення.
      </p>
      <h5>Що є глобальним лексичним оточенням?</h5>
      <p>У несуворому режимі це window. У суворому - undefined.</p>
      <h5>Що таке замикання (Closures)?</h5>
      <p>
        Це здатність функції під час створення запам'ятовувати посилання на
        змінні, функції та параметри, що знаходяться в поточному лексичному
        оточенні, а також у лексичному оточенні батьківської функції й так до
        глобального лексичного оточення. Замикання передбачає саме зовнішні
        змінні, а не саму функцію.
      </p>
      <h5>Для чого використовують замикання?</h5>
      <p>
        1 - Часто для створення приватних змінних та функцій (інкапсуляція). 2 -
        Для збереження проміжних параметрів виклику функції (каррування).
      </p>
      <h5>Що таке IIFE?</h5>
      <p>
        Immediately Invoked Function Expression - це функція, яка викликається
        або виконується одразу після створення або оголошення.
      </p>
      <h5>Що таке this?</h5>
      <p>
        Це посилання на контекст виклику функції. Контекстом є об'єкт, який в
        цей момент виконує або викликає функцію. Для стрілочної функції — це
        об'єкт у якому вона створена, а у звичайній функції — яким вона
        викликана. Контекстом може бути: 1 - this в об'єкті — вказує на сам
        об'єкт 2 - this в класі — вказує на екземпляр класу 3 - глобальним
        контекстом є window (або undefined в режимі use strict)
      </p>
      <h5>Як можна підмінити контекст виклику функції?</h5>
      <p>
        Є 3 методи: call, apply, bind. call та apply викликають функцію із
        заданим контекстом. bind повертає нову функцію із вже назавжди
        прив'язаним контекстом.
      </p>
      <h5>Чи можна змінити контекст функції, яку повернув метод bind?</h5>
      <p>Ні, bind прив'язує контекст назавжди.</p>
      <h5>Чи можна підмінити контекст виклику стрілочної функції?</h5>
      <p>
        Ні. Стрілочна функція не має методів call, apply, bind і своїх аналогів.
        Також вона використовує контекст у якому її створили, а не контекст у
        якому її викликали.
      </p>
      <h5>Що таке прототип об'єкта?</h5>
      <p>
        Це шаблон об'єкта. Він використовується як запасний варіант для
        властивостей та методів, що існують у цьому об'єкті. Це також один зі
        способів обміну властивостями та функціональністю між об'єктами. Це
        основна концепція прототипного наслідування в JS.
      </p>
      <h5>Як працює прототипне наслідування в JavaScript?</h5>
      <p>
        Коли ми хочемо прочитати властивість з об'єкта, а вона відсутня -
        JavaScript спробує прочитати його з прототипу об'єкта. Якщо властивості
        немає в прототипі, JavaScript намагатиметься його прочитати з прототипу
        прототипу, і т.д. доки властивість не буде знайдено або ланцюжок
        прототипів не закінчиться. У такому разі JavaScript поверне undefined.
      </p>
      <h5>Як створити об'єкт у якому не буде прототипу?</h5>
      <p>
        Використати Object.create(). Цей метод приймає першим аргументом об'єкт,
        який буде прототипом об'єкта, який він поверне. Якщо ми викличемо
        Object.create() з аргументом null, буде створено об'єкт без прототипу.
      </p>
      <h5>
        Як перевірити чи є властивість об'єкта особистою властивістю або це
        властивість прототипу?
      </h5>
      <p>
        Можна використовувати метод hasOwnProperty, який повертає true або
        false, в залежності від того, чи містить об'єкт зазначену властивість,
        як власну властивість, чи ні.
      </p>
      <h5>Як заборонити змінювати об'єкт?</h5>
      <p>
        Є метод Object.freeze(), який "заморожує" об'єкт від змін. Цей метод
        працює тільки в один бік. Скасувати дію цього методу вже неможливо. Є
        метод Object.seal(), який забороняє додавати нові властивості, але вже
        наявні властивості можна змінювати. Також є метод
        Object.preventExtensions(), який забороняє додавати нові властивості в
        об'єкт.
      </p>
      <h5>Що таке дескриптори властивостей об'єкта?</h5>
      <p>
        Дескриптор — це об'єкт конфігурації властивості в об'єкті. Він має 4
        властивості: value - значення властивості об'єкта, writable - вказує чи
        можна змінювати значення цієї властивості, enumerable - вказує чи буде
        видно властивість під час перебору властивостей об'єкта, configurable -
        вказує чи можна додавати або видаляти властивості об'єкта, а також чи
        можна змінювати дескриптори його властивостей.
      </p>
      <h5>Чим відрізняється функція конструктор та клас?</h5>
      <p>
        Клас — це синтаксичний цукор над функцією конструктора. Під час
        створення екземпляра класу, методи описані в ньому потрапляють у
        прототип, а методи описані всередині функції конструктора потраплять у
        сам екземпляр. Для того, щоб методи, описані всередині функції
        конструктора, потрапили в прототип, їх потрібно окремо туди додати.
      </p>
      <h5>Що потрібно зробити, щоб метод класу потрапив до його екземпляра?</h5>
      <p>Такий метод слід описати всередині конструктора.</p>
      <h5>Чи є в JavaScript множинне наслідування?</h5>
      <p>
        Ні, тому що наслідування в JavaScript базується на прототипах, а в
        одного об'єкта може бути лише один прототип.
      </p>
      <h5>Що таке Promise?</h5>
      <p>
        Це об'єкт, який використовують для відкладених та асинхронних обчислень.
        Promise має 3 стани: - очікування (pending): початковий стан, не
        виконаний та не відхилений. - виконано (fulfilled): операцію завершено
        успішно. - відхилено (rejected): операцію завершено з помилкою.
      </p>
      <h5>Для чого потрібен метод Promise.all?</h5>
      <p>
        Очікує виконання всіх промісів або відхилення будь-якого з них. Повертає
        проміс, який виконається після виконання всіх промісів. У випадку, якщо
        будь-який з промісів буде відхилено, Promise.all також буде відхилено. У
        нього є аналог Promise.allSetled, який виконується як тільки всі
        отримані проміси завершені (виконані або відхилені), що містить масив
        результатів виконання отриманих промісів.
      </p>
      <h5>Для чого потрібен метод Promise.race?</h5>
      <p>
        Очікує виконання або відхилення будь-якого з отриманих промісів.
        Повертає проміс, який буде виконано або відхилено з результатом
        виконання першого виконаного або відхиленого промісу.
      </p>
      <h5>Для чого потрібна async/await функція?</h5>
      <p>
        Ключове слово async робить створену функцію асинхронною. Функція async
        може містити вираз await, який призупиняє виконання функції async і
        чекає відповіді від переданого Promise, потім відновлює виконання
        функції async і повертає отримане значення.
      </p>
      <h5>Як обробляти помилки в async/await функції?</h5>
      <p>
        1 - Для цього можна використовувати конструкцію try...catch() 2 -
        викликати метод .catch() після виклику функції.
      </p>
      <h5>Що таке event loop?</h5>
      <p>
        Це механізм, який відповідає за виконання коду, збору та обробки подій
        та виконання підзадач із черги. У концепції event loop є кілька блоків:
        - call stack - відповідає за створення контексту виконання функції.
        Кожна функція, що викликається, потрапляє в call stack. - heap - це
        велика не структурована область пам'яті, в якій зберігаються оголошені
        змінні, функції тощо. - third party API - API, які надає оточення.
        Наприклад, метод fetch, який надається браузером. - queue - список
        завдань, що підлягають обробці. Кожне завдання асоціюється з деякою
        функцією, яка буде викликана, щоб опрацювати це завдання.
      </p>
      <h5>В чому різниця між cookie, sessionStorage та localStorage?</h5>
      <p>
        localStorage:
        <br />
        - зберігає дані безстроково.
        <br />
        - очищається тільки за допомогою JavaScript або чищення кешу браузера.
        <br />
        - зберігає дані об'ємом до 5 МБ.
        <br />
        - не підтримується старими браузерами, наприклад, IE 7 та нижче.
        <br />
        - працює за правилом обмеження домену (same origin policy).
        <br />
        sessionStorage:
        <br />
        - зберігає дані, доки триває поточна сесія вкладки.
        <br />
        - кожна вкладка має свій sessionStorage.
        <br />
        - зберігає дані об'ємом до 5 МБ.
        <br />
        - не підтримується старими браузерами, наприклад, IE 7 та нижче.
        <br />
        cookie:
        <br />
        - зберігає дані, що передаються на сервер через заголовки.
        <br />
        - мають термін зберігання даних.
        <br />
        - обсяг даних від 4 Кбайт до 32 Кбайт.
        <br />- сookie можуть бути захищеними, в цьому випадку їх вміст не можна
        отримати на стороні клієнта. Це важливо для аутентифікації при
        зберіганні користувальницьких токенів.
      </p>
    </>
  );
};

export default TechInterview;
